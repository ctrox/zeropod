package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/containerd/containerd/v2/cmd/containerd/server/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const (
	// fullContainerdConfigV2 was extracted from a Kind cluster
	fullContainerdConfigV2 = `
# explicitly use v2 config format
version = 2

[proxy_plugins]
# fuse-overlayfs is used for rootless
[proxy_plugins."fuse-overlayfs"]
  type = "snapshot"
  address = "/run/containerd-fuse-overlayfs.sock"

[plugins."io.containerd.grpc.v1.cri".containerd]
  # save disk space when using a single snapshotter
  discard_unpacked_layers = true
  # explicitly use default snapshotter so we can sed it in entrypoint
  snapshotter = "overlayfs"
  # explicit default here, as we're configuring it below
  default_runtime_name = "runc"
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
  # set default runtime handler to v2, which has a per-pod shim
  runtime_type = "io.containerd.runc.v2"
  # Generated by "ctr oci spec" and modified at base container to mount product_uuid
  base_runtime_spec = "/etc/containerd/cri-base.json"
  [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
    # use systemd cgroup by default
    SystemdCgroup = true

# Setup a runtime with the magic name ("test-handler") used for Kubernetes
# runtime class tests ...
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.test-handler]
  # same settings as runc
  runtime_type = "io.containerd.runc.v2"
  base_runtime_spec = "/etc/containerd/cri-base.json"
  [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.test-handler.options]
    SystemdCgroup = true

[plugins."io.containerd.grpc.v1.cri"]
  # use fixed sandbox image
  sandbox_image = "registry.k8s.io/pause:3.7"
  # allow hugepages controller to be missing
  # see https://github.com/containerd/cri/pull/1501
  tolerate_missing_hugepages_controller = true
  # restrict_oom_score_adj needs to be true when running inside UserNS (rootless)
  restrict_oom_score_adj = true
`
	configV3 = `
version = 3
`
	configWithOptPlugin = `
version = 2

[plugins."io.containerd.internal.v1.opt"]
  path = "/opt"
`
	configWithImports = `
version = 2
imports = ["/etc/containerd/foo_*.toml", "./bar*.toml"]
`
	configWithZeropodImport = `
version = 2
imports = ["/etc/containerd/foo_*.toml", "runtime_zeropod.toml"]
`
	configWithMultilineImports = `
version = 2

imports = [
  "/etc/containerd/foo_*.toml",
  "./bar*.toml",
]
`
	configWithMultilineImportsZeropod = `
version = 2

imports = [
  "/etc/containerd/foo_*.toml",
  "./bar*.toml",
  "runtime_zeropod.toml",
]
`
)

var containerdv1AlreadyConfigured = fullContainerdConfigV2 + fmt.Sprintf(runtimeConfig, strings.TrimSuffix(defaultOptPath, "/"), true) + `
[plugins."io.containerd.internal.v1.opt"]
  path = "/opt/zeropod"
`

type testConfig struct {
	containerdConfig       string
	runtime                containerRuntime
	expectedRestart        bool
	preCreateZeropodConfig bool
	newConfigSuffix        string
	expectedOptPath        string
	containerdv1           bool
}

func TestConfigureContainerd(t *testing.T) {
	for name, tc := range map[string]testConfig{
		"full config": {
			containerdConfig: fullContainerdConfigV2,
			runtime:          runtimeContainerd,
			expectedRestart:  true,
		},
		"v3 config": {
			containerdConfig: configV3,
			runtime:          runtimeContainerd,
			expectedRestart:  true,
		},
		"with imports already defined": {
			containerdConfig: configWithImports,
			runtime:          runtimeContainerd,
			expectedRestart:  true,
		},
		"with multiline-imports already defined": {
			containerdConfig: configWithMultilineImports,
			runtime:          runtimeContainerd,
			expectedRestart:  true,
		},
		"with zeropod import already defined": {
			containerdConfig:       configWithZeropodImport,
			runtime:                runtimeContainerd,
			preCreateZeropodConfig: true,
			expectedRestart:        false,
		},
		"with zeropod multiline-imports already defined": {
			containerdConfig:       configWithMultilineImportsZeropod,
			runtime:                runtimeContainerd,
			preCreateZeropodConfig: true,
			expectedRestart:        false,
		},
		"with opt plugin defined": {
			containerdConfig: configWithOptPlugin,
			runtime:          runtimeContainerd,
			expectedRestart:  true,
			expectedOptPath:  "/opt",
		},
		"k3s config": {
			containerdConfig: fullContainerdConfigV2,
			runtime:          runtimeK3S,
			expectedRestart:  true,
			newConfigSuffix:  templateSuffix,
		},
		"rke2 config": {
			containerdConfig: fullContainerdConfigV2,
			runtime:          runtimeRKE2,
			expectedRestart:  true,
			newConfigSuffix:  templateSuffix,
		},
		"full config v1": {
			containerdConfig: fullContainerdConfigV2,
			runtime:          runtimeContainerd,
			expectedRestart:  true,
			containerdv1:     true,
		},
		"config v1 already configured": {
			containerdConfig:       containerdv1AlreadyConfigured,
			runtime:                runtimeContainerd,
			preCreateZeropodConfig: true,
			expectedRestart:        false,
			containerdv1:           true,
		},
	} {
		t.Run(name, func(t *testing.T) {
			if tc.expectedOptPath == "" {
				tc.expectedOptPath = defaultOptPath
			}
			assert := assert.New(t)
			require := require.New(t)
			configName := setupTestConfig(t, tc)
			var restart bool
			var err error
			if tc.containerdv1 {
				restart, err = configureContainerdv1(context.Background(), tc.runtime, configName)
			} else {
				restart, err = configureContainerdv2(context.Background(), tc.runtime, configName)
			}
			require.NoError(err)
			newFile, err := os.ReadFile(configName + tc.newConfigSuffix)
			require.NoError(err)
			backupConfig, err := os.ReadFile(configName + configBackupSuffix)
			require.NoError(err)

			ctx := context.Background()
			conf := &config.Config{}
			assert.NoError(config.LoadConfig(ctx, configName+tc.newConfigSuffix, conf))

			if !tc.containerdv1 {
				zeropodConfig, err := os.ReadFile(zeropodRuntimeConfigPath(tc.runtime, configName))
				require.NoError(err)
				assert.NotEmpty(zeropodConfig)
				t.Log(string(zeropodConfig))
				assert.Contains(conf.Imports, zeropodTomlName)
			}

			assert.NotEmpty(backupConfig)
			assert.Equal(tc.containerdConfig, string(backupConfig))
			assert.NotEmpty(newFile)
			assert.Equal(tc.expectedRestart, restart)

			hasOpt, containerdOptPath, err := optConfigured(ctx, configName+tc.newConfigSuffix)
			require.NoError(err)
			assert.True(hasOpt)
			assert.Equal(tc.expectedOptPath, containerdOptPath)
			t.Log(string(newFile))
		})
	}
}

func TestConfigureContainerdK0s(t *testing.T) {
	t.Run("writes drop-in", func(t *testing.T) {
		temp := t.TempDir()
		cfg := filepath.Join(temp, "containerd.toml")
		managedConfig := []byte("# " + k0sManagedSentinel + "\nversion = 2\n")
		require.NoError(t, os.WriteFile(cfg, managedConfig, 0644))

		restart, err := configureContainerdK0s(context.Background(), cfg)
		require.NoError(t, err)
		assert.False(t, restart)

		dropIn := filepath.Join(filepath.Dir(cfg), k0sDropInDirName, zeropodTomlName)
		data, err := os.ReadFile(dropIn)
		require.NoError(t, err)
		assert.Contains(t, string(data), "runtime_type = \"io.containerd.runc.v2\"")
	})

	t.Run("requires managed config", func(t *testing.T) {
		temp := t.TempDir()
		cfg := filepath.Join(temp, "containerd.toml")
		require.NoError(t, os.WriteFile(cfg, []byte("version = 2\n"), 0644))

		_, err := configureContainerdK0s(context.Background(), cfg)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "not k0s managed")
	})
}

func setupTestConfig(t *testing.T, tc testConfig) string {
	temp := t.TempDir()
	configFile, err := os.CreateTemp(temp, "containerd-config-*.toml")
	require.NoError(t, err)
	require.NoError(t, os.WriteFile(configFile.Name(), []byte(tc.containerdConfig), 0644))

	if tc.preCreateZeropodConfig {
		if !tc.containerdv1 {
			require.NoError(t, writeZeropodRuntimeConfig(tc.runtime, configFile.Name(), tc.expectedOptPath, tc.expectedOptPath == "", 2, useSystemdCgroup(tc.runtime)))
		}
		require.NoError(t, backupContainerdConfig(configFile.Name()))
	}
	return configFile.Name()
}
